const { db } = require('../../config/firebase');

/**
 * Handle fetching responses for a given reviewId.
 */
const getResponses = async (req, res) => {
    try {
        const { reviewId } = req.query;

        if (!reviewId) {
            return res.status(400).json({ success: false, error: 'reviewId query parameter is required', code: 400 });
        }

        const responsesRef = db.collection('responses');
        const snapshot = await responsesRef.where('reviewId', '==', reviewId).get();

        const responses = [];
        snapshot.forEach(doc => {
            responses.push({ id: doc.id, ...doc.data() });
        });

        return res.status(200).json({
            success: true,
            data: responses
        });

    } catch (error) {
        console.error('getResponses Error:', error);
        return res.status(500).json({ success: false, error: 'Internal Server Error', code: 500 });
    }
};

/**
 * Create a response to a review.
 * Also updates the origin review's `responseStatus` to 'responded'.
 */
const createResponse = async (req, res) => {
    try {
        const { uid: respondedBy, role: currentUserRole, branchId: userBranchId } = req.user;
        const { reviewId, responseText, autoGenerated } = req.body;

        if (!reviewId || !responseText) {
            return res.status(400).json({ success: false, error: 'Missing reviewId or responseText', code: 400 });
        }

        // Fetch the review to validate branch boundaries
        const reviewRef = db.collection('reviews').doc(reviewId);
        const reviewDoc = await reviewRef.get();

        if (!reviewDoc.exists) {
            return res.status(404).json({ success: false, error: 'Review not found', code: 404 });
        }

        const reviewData = reviewDoc.data();

        if (currentUserRole !== 'admin' && reviewData.branchId !== userBranchId) {
            return res.status(403).json({ success: false, error: 'Forbidden: Cannot respond to reviews outside of your branch', code: 403 });
        }

        if (reviewData.responseStatus === 'responded') {
            return res.status(400).json({ success: false, error: 'Review has already been responded to', code: 400 });
        }

        // Run a Firestore batch/transaction to add response AND update review status reliably
        const batch = db.batch();

        const newResponseRef = db.collection('responses').doc();
        const newResponseData = {
            reviewId,
            responseText,
            autoGenerated: autoGenerated || false,
            respondedBy,
            respondedAt: new Date().toISOString()
        };

        batch.set(newResponseRef, newResponseData);
        batch.update(reviewRef, { responseStatus: 'responded' });

        await batch.commit();

        return res.status(201).json({
            success: true,
            data: { id: newResponseRef.id, ...newResponseData }
        });

    } catch (error) {
        console.error('createResponse Error:', error);
        return res.status(500).json({ success: false, error: 'Internal Server Error', code: 500 });
    }
};

module.exports = {
    getResponses,
    createResponse
};
